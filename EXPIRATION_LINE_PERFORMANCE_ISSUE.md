# Проблема производительности: Линия экспирации и кроссхейр

## Описание проблемы

**Симптомы:**
- Когда график отлистывается так, что линия экспирации уходит за пределы viewport (вне видимой области экрана)
- Кроссхейр пропадает или перестает работать корректно
- График начинает сильно лагать и фризить

**Воспроизведение:**
1. Открыть график с активной линией экспирации
2. Отлистать график влево или вправо так, чтобы линия экспирации ушла за пределы экрана
3. Проблема проявляется сразу после того, как линия уходит за пределы viewport

---

## Архитектура компонентов

### 1. Viewport (useViewport.ts)

**Ответственность:**
- Хранение состояния viewport (timeStart, timeEnd, priceMin, priceMax)
- Инициализация на основе данных свечей
- Auto-fit по Y оси
- Пересчет при изменении данных

**Ключевые свойства:**
```typescript
interface Viewport {
  timeStart: number;  // Начало временного диапазона (timestamp в мс)
  timeEnd: number;    // Конец временного диапазона (timestamp в мс)
  priceMin: number;   // Минимальная цена
  priceMax: number;   // Максимальная цена
}
```

**Важно:** Viewport определяет видимую область графика. Все элементы рендерятся относительно этого viewport.

---

### 2. Render Loop (useRenderLoop.ts)

**Ответственность:**
- Главный цикл рендеринга через `requestAnimationFrame`
- Координация всех элементов рендеринга
- Последовательность отрисовки элементов

**Порядок рендеринга (снизу вверх):**
1. Очистка canvas (`ctx.clearRect`)
2. Grid (сетка)
3. Candles (свечи) через `renderEngine`
4. Индикаторы
5. **Crosshair** (строка 519-527)
6. Trades (сделки)
7. Drawings (рисунки)
8. Price alerts
9. **Expiration line** (строка 319-455)
10. Countdown timer
11. Crosshair time label (строка 603-605)
12. Market overlay (если рынок закрыт)

**Критический момент:** Expiration line рендерится ПОСЛЕ crosshair, но crosshair time label рендерится ПОСЛЕ expiration line.

---

### 3. Линия экспирации (Expiration Line)

**Расположение:** `useRenderLoop.ts`, строки 319-455

**Логика работы:**

#### 3.1. Получение timestamp экспирации
```typescript
const rawExpirationTimestamp = getExpirationTime?.();
```
- Получает время экспирации в миллисекундах (server time anchor)
- Может быть `null` или `undefined`

#### 3.2. Анимация линии экспирации

**Состояние анимации (refs):**
- `expirationRenderTimeRef` - текущее отображаемое время (анимированное)
- `expirationTargetTimeRef` - целевое время (куда анимируется)
- `expirationAnimStartTimeRef` - время начала анимации
- `expirationAnimStartValueRef` - начальное значение для анимации

**Логика анимации:**
1. Если первый раз или раньше линии не было → устанавливается без анимации
2. Если разница между текущим и целевым временем > 1500мс → запускается анимация
3. Анимация использует easeInOutSmooth функцию
4. Длительность анимации: 320мс

**Проблема:** Анимация обновляется КАЖДЫЙ КАДР через `requestAnimationFrame`, даже когда линия не видна.

#### 3.3. Вычисление позиции X

```typescript
const timeToX = (time: number): number =>
  ((time - viewport.timeStart) / (viewport.timeEnd - viewport.timeStart)) * width;

const x = timeToX(effectiveTimestamp);
```

**Проблема:** Когда `rawExpirationTimestamp` далеко от `viewport.timeStart` или `viewport.timeEnd`, значение `x` может быть:
- Очень большим отрицательным числом (если timestamp слева от viewport)
- Очень большим положительным числом (если timestamp справа от viewport)
- `Infinity` или `NaN` при делении на ноль или очень маленьком диапазоне

#### 3.4. Проверка видимости

```typescript
const PRICE_LABEL_AREA_WIDTH = 60;
const maxX = width - PRICE_LABEL_AREA_WIDTH;

if (x < 0 || x > maxX) {
  return; // Не рендерим линию
}
```

**Текущая реализация:**
- Проверка выполняется ПОСЛЕ обновления анимации
- Анимация продолжает обновляться даже когда `x < 0 || x > maxX`
- Это означает, что вычисления происходят каждый кадр, даже когда линия не видна

#### 3.5. Рендеринг линии

**Элементы:**
1. Кружок сверху (радиус 18px, позиция Y = 30px)
2. Флажок финиша внутри кружка (2x8 клеток)
3. Вертикальная линия от кружка до меток времени

**Canvas операции:**
- `ctx.save()` перед рендерингом
- Множество операций рисования (arc, fillRect, strokeRect, lineTo)
- `ctx.restore()` после рендеринга

**Проблема:** Если `x` вычисляется неправильно (очень большое число, Infinity, NaN), операции canvas могут:
- Рисовать за пределами canvas
- Вызывать ошибки в браузере
- Портить состояние контекста canvas

---

### 4. Кроссхейр (Crosshair)

**Расположение:** 
- Рендеринг: `renderCrosshair.ts`
- Вызов: `useRenderLoop.ts`, строка 519-527

**Логика работы:**

#### 4.1. Получение состояния
```typescript
const crosshair = getCrosshair();
```

#### 4.2. Рендеринг
- Вертикальная линия (если `crosshair.isActive`)
- Горизонтальная линия (если `crosshair.isActive`)
- Метка цены справа
- Кнопка добавления алерта (plus button)

**Canvas операции:**
- Использует те же цвета и стили, что и линия экспирации
- Рисует линии, прямоугольники, текст

**Проблема:** Если состояние canvas было испорчено предыдущими операциями (например, от линии экспирации), кроссхейр может:
- Не отображаться корректно
- Иметь неправильные цвета/стили
- Полностью пропадать

---

## Анализ проблемы

### Гипотеза 1: Порча состояния Canvas контекста

**Проблема:** Когда линия экспирации уходит за пределы viewport:
1. `x` становится очень большим числом (например, -10000 или 50000)
2. Canvas операции пытаются рисовать за пределами canvas
3. Состояние контекста (`ctx`) портится
4. Последующие операции (кроссхейр) работают некорректно

**Доказательства:**
- Кроссхейр рендерится ПОСЛЕ expiration line в коде
- Но expiration line может испортить состояние canvas
- Проверка `x < 0 || x > maxX` происходит ПОСЛЕ обновления анимации

### Гипотеза 2: Избыточные вычисления каждый кадр

**Проблема:** Анимация линии экспирации обновляется каждый кадр, даже когда линия не видна:
1. Вычисление `timeToX` с очень большими числами
2. Обновление ref'ов анимации
3. Математические операции с большими числами
4. Это может вызывать лаги

**Доказательства:**
- Анимация обновляется в строках 322-365
- Проверка видимости происходит только в строке 380
- Если `x` очень большое, вычисления могут быть медленными

### Гипотеза 3: Проблемы с делением на ноль или очень маленьким диапазоном

**Проблема:** Когда viewport очень узкий или timestamp очень далеко:
```typescript
const timeRange = viewport.timeEnd - viewport.timeStart;
const x = ((time - viewport.timeStart) / timeRange) * width;
```

Если `timeRange` очень маленький или `time` очень далеко, результат может быть:
- `Infinity`
- `-Infinity`
- `NaN`

**Доказательства:**
- Нет проверки на `timeRange <= 0`
- Нет проверки на `isFinite(x)` перед использованием

### Гипотеза 4: Несбалансированные save/restore

**Проблема:** В коде есть проверка:
```typescript
if (x > maxX) {
  ctx.restore(); // ❌ ПРОБЛЕМА: restore без save!
  return;
}
```

Но это было исправлено. Однако может быть другая проблема:
- Если `x` вычисляется неправильно, `ctx.save()` может не вызываться
- Или `ctx.restore()` может вызываться лишний раз

---

## Текущие попытки исправления

### Попытка 1: Проверка видимости перед обновлением анимации

**Изменения:**
- Добавлена проверка `isNearVisible` перед обновлением анимации
- Анимация обновляется только если линия близко к видимой области

**Результат:** Не помогло полностью

### Попытка 2: Убрать `ctx.restore()` без `ctx.save()`

**Изменения:**
- Убран `ctx.restore()` в проверке `x > maxX`
- Добавлена проверка на `x < 0`

**Результат:** Не помогло полностью

### Попытка 3: Добавлена защита от деления на ноль

**Изменения:**
- Проверка `timeRange <= 0` в `timeToX`
- Возврат `-Infinity` если диапазон невалидный

**Результат:** Не помогло полностью

---

## Рекомендации для исправления

### 1. Ранняя проверка видимости

**Проблема:** Проверка видимости происходит ПОСЛЕ обновления анимации.

**Решение:** Проверить видимость ДО обновления анимации:
```typescript
// Сначала проверяем видимость
const rawX = timeToX(rawExpirationTimestamp);
if (rawX < -width * 2 || rawX > width * 2) {
  // Линия очень далеко, не обновляем анимацию
  return;
}

// Только потом обновляем анимацию
// ... код анимации ...
```

### 2. Защита от некорректных значений

**Проблема:** `x` может быть `Infinity`, `NaN`, или очень большим числом.

**Решение:** Добавить проверки:
```typescript
const x = timeToX(effectiveTimestamp);
if (!Number.isFinite(x) || x < -width * 10 || x > width * 10) {
  return; // Не рендерим если значение некорректное
}
```

### 3. Оптимизация анимации

**Проблема:** Анимация обновляется каждый кадр даже когда не видна.

**Решение:** Остановить анимацию когда линия не видна:
```typescript
if (!isNearVisible && !hasActiveAnimation) {
  // Не обновляем анимацию если линия не видна и анимация не активна
  return;
}
```

### 4. Проверка состояния Canvas

**Проблема:** Состояние canvas может быть испорчено.

**Решение:** Добавить проверки перед критическими операциями:
```typescript
// Перед рендерингом кроссхейра
ctx.save(); // Сохраняем состояние
try {
  renderCrosshair(...);
} finally {
  ctx.restore(); // Восстанавливаем состояние
}
```

### 5. Логирование для отладки

**Решение:** Добавить логирование для понимания проблемы:
```typescript
if (x < -width || x > width * 2) {
  console.warn('Expiration line far outside viewport:', {
    x,
    rawTimestamp: rawExpirationTimestamp,
    viewportStart: viewport.timeStart,
    viewportEnd: viewport.timeEnd,
    timeRange: viewport.timeEnd - viewport.timeStart
  });
}
```

---

## Вопросы для дальнейшего исследования

1. **Когда именно пропадает кроссхейр?**
   - Сразу после того как линия уходит за пределы?
   - Или после некоторого времени?

2. **Что происходит с производительностью?**
   - FPS падает постепенно или сразу?
   - Есть ли ошибки в консоли браузера?

3. **Зависит ли проблема от направления прокрутки?**
   - Проблема только когда линия уходит вправо?
   - Или также когда уходит влево?

4. **Влияет ли наличие активной анимации?**
   - Проблема только когда анимация активна?
   - Или также когда анимации нет?

5. **Что происходит с другими элементами?**
   - Пропадают ли другие элементы кроме кроссхейра?
   - Или проблема только с кроссхейром?

---

## Файлы для проверки

1. `frontend/components/chart/internal/useRenderLoop.ts` - строки 319-455 (expiration line)
2. `frontend/components/chart/internal/useRenderLoop.ts` - строки 519-527 (crosshair)
3. `frontend/components/chart/internal/crosshair/renderCrosshair.ts` - весь файл
4. `frontend/components/chart/internal/useViewport.ts` - логика viewport

---

## Выводы

Основная проблема, вероятно, связана с:
1. **Порчей состояния Canvas контекста** из-за некорректных значений `x`
2. **Избыточными вычислениями** каждый кадр даже когда линия не видна
3. **Отсутствием защиты** от некорректных значений (Infinity, NaN, очень большие числа)

Рекомендуется:
- Добавить раннюю проверку видимости
- Добавить защиту от некорректных значений
- Оптимизировать анимацию для невидимых элементов
- Добавить логирование для отладки
